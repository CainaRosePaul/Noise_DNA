import pandas as pd
import subprocess
import os
import yaml
from sklearn.feature_extraction.text import CountVectorizer
from sklearn.naive_bayes import MultinomialNB
from sklearn.metrics import classification_report, accuracy_score

def load_config(file_path):
    """Load the configuration from a YAML file."""
    with open(file_path, 'r') as file:
        return yaml.safe_load(file)

def load_data(input_file):
    """Load dataset and split into train and test sets."""
    data = pd.read_csv(input_file)
    train_set = data[data['set'] == 'train']
    test_set = data[data['set'] == 'test']
    return train_set, test_set

def save_data(train_set, test_set, train_output, test_output):
    """Save train and test datasets to CSV files."""
    train_set.to_csv(train_output, index=False)
    test_set.to_csv(test_output, index=False)

def simulate_art(config, positive_sequences):
    """Simulate sequencing using ART based on the positive sequences."""
    os.makedirs(os.path.dirname(config['dataset']['art_fasta']), exist_ok=True)
    with open(config['dataset']['art_fasta'], 'w') as fasta_file:
        for idx, seq in enumerate(positive_sequences):
            fasta_file.write(f'>seq{idx}\n{seq}\n')
    
    art_command = (
        f"{config['art_simulator']['executable_path']} "
        f"-i \"{config['dataset']['art_fasta']}\" "
        f"-l {config['art_simulator']['read_length']} "
        f"-f {config['art_simulator']['flowcell_type']} "
        f"-o \"{config['dataset']['art_output']}\""
    )
    
    subprocess.run(art_command, shell=True)

def load_noisy_sequences(output_file):
    """Load noisy sequences from the FASTQ file generated by ART."""
    noisy_sequences = []
    with open(output_file, 'r') as fastq_file:
        lines = fastq_file.readlines()
        for i in range(0, len(lines), 4):
            sequence = lines[i + 1].strip()
            noisy_sequences.append(sequence)
    return noisy_sequences

def combine_test_sets(noisy_sequences, negative_sequences):
    """Combine noisy sequences with negative test sequences."""
    noisy_test_set = pd.DataFrame(noisy_sequences, columns=['seq'])
    noisy_test_set['class'] = 1
    noisy_test_set['set'] = 'test_noisy'
    
    return pd.concat(
        [noisy_test_set[['seq', 'class', 'set']], 
         negative_sequences[['seq', 'class', 'set']]], 
        ignore_index=True
    )

def train_model(train_set, ngram_range):
    """Train the Naive Bayes model using the specified n-gram range."""
    # Ensure ngram_range is a tuple
    if isinstance(ngram_range, list):
        ngram_range = tuple(ngram_range)  # Convert list to tuple if necessary
    
    vectorizer = CountVectorizer(analyzer='char', ngram_range=ngram_range)
    X_train = vectorizer.fit_transform(train_set['seq'])
    y_train = train_set['class']
    model = MultinomialNB()
    model.fit(X_train, y_train)
    return model, vectorizer

def evaluate_model(model, vectorizer, test_set):
    X_test = vectorizer.transform(test_set['seq'])
    y_test = test_set['class']
    y_pred = model.predict(X_test)

    # Calculate performance metrics
    report = classification_report(y_test, y_pred, output_dict=True)
    
    # Print results to the console
    print("Performance on Test Set:")
    print(classification_report(y_test, y_pred))
    print(f'Accuracy: {accuracy_score(y_test, y_pred):.2f}\n')
    
    # Save to a text file
    with open("C:/Users/caina/Documents/dna/evaluation_results.txt", "a") as f:
        f.write("Performance on Test Set:\n")
        f.write(classification_report(y_test, y_pred))
        f.write(f'Accuracy: {accuracy_score(y_test, y_pred):.2f}\n\n')


def evaluate_model_noise(model, vectorizer, test_set):
    X_test = vectorizer.transform(test_set['seq'])
    y_test = test_set['class']
    y_pred = model.predict(X_test)

    # Calculate performance metrics
    report = classification_report(y_test, y_pred, output_dict=True)
    
    # Print results to the console
    print("Performance on Noise Test Set:")
    print(classification_report(y_test, y_pred))
    print(f'Accuracy: {accuracy_score(y_test, y_pred):.2f}\n')
    
    # Save to a text file
    with open("C:/Users/caina/Documents/dna/evaluation_results.txt", "a") as f:
        f.write("Performance on Noise Test Set:\n")
        f.write(classification_report(y_test, y_pred))
        f.write(f'Accuracy: {accuracy_score(y_test, y_pred):.2f}\n\n')

def main():
    # Make sure to specify the correct path to your config file
    config = load_config('C:/Users/caina/Documents/dna/conf/base/config.yaml')

    train_set, test_set = load_data(config['dataset']['input_file'])
    save_data(train_set, test_set, config['dataset']['train_set_output'], config['dataset']['test_set_output'])
    
    positive_test_sequences = test_set[test_set['class'] == 1]['seq']
    simulate_art(config, positive_test_sequences)

    
    noisy_sequences = load_noisy_sequences(f"{config['dataset']['art_output']}.fq")
    negative_test_sequences = test_set[test_set['class'] == 0]

    combined_test_set = combine_test_sets(noisy_sequences, negative_test_sequences)
    
    combined_test_set.to_csv(config['dataset']['noisy_test_set_output'], index=False)
    
    model, vectorizer = train_model(train_set, config['model']['feature_extraction']['ngram_range'])
    evaluate_model(model, vectorizer, test_set)
    evaluate_model_noise(model, vectorizer, combined_test_set)

if __name__ == "__main__":
    main()
